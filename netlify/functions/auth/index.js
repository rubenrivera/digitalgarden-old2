const cookie = require("cookie");
const { EleventyServerless } = require("@11ty/eleventy");
const { OAuth, tokens, getCookie } = require("../util/auth.js");

const faviconsPlugin = require("eleventy-plugin-gen-favicons");
const { parse } = require("node-html-parser");

// Explicit dependencies for the bundler from config file and global data.
// The file is generated by the Eleventy Serverless Bundler Plugin.
require("./eleventy-bundler-modules.js");


const Image = require("@11ty/eleventy-img");
function transformImage(src, cls, alt, sizes, widths = ["500", "700", "auto"]) {
  let options = {
    widths: widths,
    formats: ["webp", "jpeg"],
    outputDir: "./tmp/dist/img/optimized",
    urlPath: "/img/optimized",
  };

  // generate images, while this is async we don’t wait
  Image(src, options);
  let metadata = Image.statsSync(src, options);
  return metadata;
}


async function handler(event) {
  let authToken;
  let provider;
  console.log("[dynamic] GETTING COOKIES");
  if(event.headers && event.headers.cookie) {
    let cookies = cookie.parse(event.headers.cookie);
    if(cookies._11ty_oauth_provider) {
      provider = cookies._11ty_oauth_provider;
    }
    if(cookies._11ty_oauth_token) {
      if(provider === "stackexchange"){
        authToken = cookies._11ty_oauth_token;
      } else {
        authToken = tokens.decode(cookies._11ty_oauth_token);
      }
    }
  }

  let user;
  let authError;
  try {
    let oauth = new OAuth(provider);
    console.log("[auth] GETTING USER INFORMATION")
    user = await oauth.getUser(authToken, provider);
  } catch(e) {
    authError = e;
  }

  let elev = new EleventyServerless("auth", {
    path: event.path,
    query: event.queryStringParameters,
    functionsDir: "./netlify/functions/",
    config: function(eleventyConfig) {

      if(user) {
        eleventyConfig.addGlobalData("user", user);
      }

      // Adds `secure` data to JSON output
      eleventyConfig.dataFilterSelectors.add("secure");
      
      eleventyConfig.addPlugin(faviconsPlugin, { outputDir: "tmp/dist" });

      function fillPictureSourceSets(src, cls, alt, meta, width, imageTag) {
        imageTag.tagName = "picture";
        let html = `<source
          media="(max-width:480px)"
          srcset="${meta.webp[0].url}"
          type="image/webp"
          />
          <source
          media="(max-width:480px)"
          srcset="${meta.jpeg[0].url}"
          />
          `
        if (meta.webp && meta.webp[1] && meta.webp[1].url) {
          html += `<source
            media="(max-width:1920px)"
            srcset="${meta.webp[1].url}"
            type="image/webp"
            />`
        }
        if (meta.jpeg && meta.jpeg[1] && meta.jpeg[1].url) {
          html += `<source
            media="(max-width:1920px)"
            srcset="${meta.jpeg[1].url}"
            />`
        }
        html += `<img
          class="${cls.toString()}"
          src="${src}"
          alt="${alt}"
          width="${width}"
          />`;
        imageTag.innerHTML = html;
      }
    
    
      eleventyConfig.addTransform("picture", function (str) {
        if(process.env.USE_FULL_RESOLUTION_IMAGES === "true"){
          return str;
        }
        const parsed = parse(str);
        for (const imageTag of parsed.querySelectorAll(".cm-s-obsidian img")) {
          const src = imageTag.getAttribute("src");
          if (src && src.startsWith("/") && !src.endsWith(".svg")) {
            const cls = imageTag.classList.value;
            const alt = imageTag.getAttribute("alt");
            const width = imageTag.getAttribute("width") || '';
    
            try {
              const meta = transformImage(
                "./src/site" + decodeURI(imageTag.getAttribute("src")),
                cls.toString(),
                alt,
                ["(max-width: 480px)", "(max-width: 1024px)"]
              );
    
              if (meta) {
                fillPictureSourceSets(src, cls, alt, meta, width, imageTag);
              }
            } catch {
              // Make it fault tolarent.
            }
          }
        }
        return str && parsed.innerHTML;
      });

    },
    copy: [
      {
        from: ".cache",
        to: "tmp/.cache"
      },   
    ],
  });

  try {
    let [ page ] = await elev.getOutput();

    if("logout" in event.queryStringParameters) {
      let redirectTarget = page.url; // default redirect to self
      if(page.data.secure && page.data.secure.unauthenticatedRedirect) {
        redirectTarget = page.data.secure.unauthenticatedRedirect;
      }

      // console.log( "Logging out" );
      return {
        statusCode: 302,
        headers: {
          Location: redirectTarget,
          'Cache-Control': 'no-cache' // Disable caching of this response
        },
        multiValueHeaders: {
          'Set-Cookie': [
            getCookie("_11ty_oauth_token", "", -1),
            getCookie("_11ty_oauth_provider", "", -1),
          ]
        },
        body: ''
      };
    }

    // Secure pages
    if(page.data.secure && authError) {
      console.log("[serverless fn]", event.path, authToken, provider, authError );

      // unauthenticated redirect
      return {
        statusCode: 302,
        headers: {
          Location: page.data.secure.unauthenticatedRedirect || "/",
          'Cache-Control': 'no-cache' // Disable caching of this response
        },
        body: ''
      };
    }

    return {
      statusCode: 200,
      headers: {
        "Content-Type": "text/html; charset=UTF-8",
      },
      body: page.content,
    };
  } catch (error) {
    // Only console log for matching serverless paths
    // (otherwise you’ll see a bunch of BrowserSync 404s for non-dynamic URLs during --serve)
    if (elev.isServerlessUrl(event.path)) {
      console.log("Serverless Error:", error);
    }

    return {
      statusCode: error.httpStatusCode || 500,
      body: JSON.stringify(
        {
          error: error.message,
        },
        null,
        2
      ),
    };
  }
}

exports.handler = handler;
